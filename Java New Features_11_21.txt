key differences between Java 8 and Java 11

Java 11 has several performance improvements over Java 8
performance improvements
G1 garbage collector, which helps improving application performance.
Z Garbage Collector (ZGC) in Java 11. This garbage collector is designed to handle larger heap sizes with low latency.

Security enhancements

Java 11 also includes new cryptographic algorithms and TLS protocols that improve security in the platform.

Module System
Java 11 comes with an improved module system that makes it easier to create, compile, and package modules. 
This feature is not available in Java 8, which uses the traditional classpath mechanism for loading classes.
 
New APIs and Features
 
Java 11 includes the HTTP Client API, which allows developers to send HTTP requests and receive responses using a fluent and reactive API. 
Java 11 also includes the Var keyword, which allows developers to declare local variables without specifying their data types explicitly.
 
Improvements in String Class
Java 11 includes the repeat() method, which returns a string that is repeated a specified number of times. 
It also includes the isBlank() method, which checks if a string is empty or contains only white spaces.
 
Removal of Deprecated APIs-  java.xml.bind 
 
Enhanced Docker Support
Includes the ability to dynamically adjust the size of the JVM heap based on the memory limits of the container.
It also includes improvements to the logging and monitoring of containerized applications.
 
 
 Improved HTTP Support

Java 11 includes several improvements to the HTTP protocol support. For example, it includes the ability to handle HTTP/2 server push,
which allows servers to send multiple responses for a single request.
It also includes enhancements to the WebSocket API, which allows for real-time, bidirectional communication between a client and server.
 
Enhanced Security with KeyStore

Java 11 includes several enhancements to the KeyStore class, which is used to store cryptographic keys and certificates.

Performance Improvements with Graal

Java 11 includes experimental support for the Graal compiler, which is a high-performance just-in-time (JIT) compiler.
The Graal compiler offers significant performance improvements over the traditional HotSpot JIT compiler, 
particularly for applications that use a lot of reflection and dynamic class loading.
 
 
Support for Unicode 10

Java 11 includes support for Unicode 10, which adds more characters and scripts to the platform.
This includes support for new emoji characters, such as the hijab, and new scripts, such as Osage and Masaram Gondi.

Java 21 -released on September 19, 2023

String Templates:
simplify the process of string formatting and manipulation in Java .

// Before Java 21
"Hello" + name + ", welcome to the GeeksForGeeks!"  

// After Java 21
‘Hello {name} welcome to the GeeksForGeeks!’ 

Performance Improvements

Java has the feature of Z Garbage Collection (ZBC) which performs all the expensive works concurrently, without stopping the execution of application threads.
Now with the improvement of this cleaning tool called ‘ZBC’, it cleans up the unused memory.

Sequenced Collections- SequencedSet, SequencedCollection, and SequencedMap.
In JDK 21, the introduction of Sequenced Collections brings new interfaces and methods to simplify and streamline collection processing.
It address common scenarios where accessing the first and last elements of various collection types.

Java Emoji Support Tools

boolean isEmojiChar = Character.isEmoji('????');

Enhanced Repeated Appending in StringBuilder and StringBuffer
The CharSequence method lets you add a word or phrase multiple times to StringBuilder or StringBuffer.

StringBuilder sb1 = new StringBuilder();
sb1.repeat(42, 10);  // Appends "**********" to sb1

StringBuilder sb2 = new StringBuilder();
sb2.repeat("-=", 20);  // Appends "-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=" to sb2

Pattern Matching for switch
Enhance the Java programming language with pattern matching for switch expressions and statements.


// Prior to Java 21
static String formatter(Object obj) {
    String formatted = "unknown";
    if (obj instanceof Integer i) {
        formatted = String.format("int %d", i);
    } else if (obj instanceof Long l) {
        formatted = String.format("long %d", l);
    } else if (obj instanceof Double d) {
        formatted = String.format("double %f", d);
    } else if (obj instanceof String s) {
        formatted = String.format("String %s", s);
    }
    return formatted;
}

// As of Java 21
static String formatterPatternSwitch(Object obj) {
    return switch (obj) {
        case Integer i -> String.format("int %d", i);
        case Long l    -> String.format("long %d", l);
        case Double d  -> String.format("double %f", d);
        case String s  -> String.format("String %s", s);
        default        -> obj.toString();
    };
}

Virtual Threads

Java 21 introduces virtual threads, a lightweight thread type that simplifies writing and maintaining high-throughput applications.
 While it requires around 1Mb to create a traditional thread(or platform thread), a virtual thread only requires around 1Kb of memory.
 
  Thread thread = Thread.ofVirtual().start(() -> {
            System.out.println("Hello from a virtual thread!");
        });

        System.out.println(thread.isVirtual());//True
        
        
 You can also use the ExecutorService to create a large number of virtual threads:
 
  try (var executor = Executors.newVirtualThreadPerTaskExecutor()) {
            IntStream.range(0, 1_000_000).forEach(i ->
                    executor.submit(() -> {
                        // Simulate a task
                        System.out.println("Task " + i + " running");
                    })
            );
        }       






